---
title: "2025-11-03"
format:
  html: default
  pdf: default
params:
  course: "mc451"
  word_min: 250
  word_max: 300
  p1: 'Have you ever worked with a spreadsheet, dataset, or even a shared document that felt chaotic or disorganized? Describe the experience. What kinds of "messiness" did you encounter? Looking back, which data wrangling principles from this chapter would have helped clean it up?'
  p2: 'Imagine you''re analyzing survey data and discover that some responses are missing or strangely formatted. You realize you could remove them, impute values, or rewrite categories to make things "fit." What would guide your decision-making in that situation? How does data cleaning impact the honesty and transparency of research?'
  p3: 'The chapter argues that wrangling is not just technical work—it’s interpretive. Think about a time you had to make a judgment call while organizing information (e.g., editing a document, categorizing files, formatting content). How might similar interpretive choices show up in data wrangling? How does this shape the final story your data tells?'
---

## Choose **one** prompt to answer

> **Prompt A:** `r params$p1`

---

## Response

<!-- RESPONSE-START -->

Yes, I have worked with a shared Word/Google document and slideshow project that felt very chaotic and disorganized. Several people were contributing to both files, but there wasn’t much structure or communication about how to organize our work. In the Word document, people often entered information in the wrong sections or repeated what someone else had already written. Some group members weren’t very detailed, while others wrote long paragraphs that didn’t match the rest of the document’s tone. There were also different writing styles, inconsistent fonts and headings, and no clear format for citing sources or labeling sections. The slideshow was just as messy, slides were out of order, text formatting changed from one slide to the next, and there were different color schemes and bullet styles throughout. Overall, it was difficult to tell what information was finalized and what still needed to be edited. Several data wrangling principles from the chapter would have been useful in this situation. The cleaning phase, which involves standardizing and organizing information, could have helped us maintain a consistent structure across the Word document and slides. Establishing clear formatting rules and ensuring everyone followed them would have reduced confusion and made the project look more professional. The transforming phase also relates to reorganizing data into a clear and usable format, similar to rearranging slides or reorganizing sections in the Word document so that the information flowed logically. Finally, the idea of a reproducible workflow could have helped our group document who made what changes and when, keeping the editing process transparent and easier to manage. Following these principles would have saved us time and made the final project much more cohesive.

<!-- RESPONSE-END -->

---

## Word Count & Range Check

```{r}
#| echo: false
#| message: false
#| warning: false
get_response_text <- function() {
  f <- knitr::current_input()
  if (is.null(f) || !file.exists(f)) return("")
  x <- readLines(f, warn = FALSE)
  # Find the lines that EXACTLY match the start/end markers
  s <- grep("^<!-- RESPONSE-START -->$", x)
  e <- grep("^<!-- RESPONSE-END -->$", x)
  if (length(s) != 1 || length(e) != 1 || e <= s) return("")
  paste(x[(s + 1L):(e - 1L)], collapse = "\n")
}
count_words <- function(txt) {
  # Remove code blocks and inline code before counting
  txt <- gsub("```[\\s\\S]*?```", " ", txt, perl = TRUE)
  txt <- gsub("`[^`]*`", " ", txt, perl = TRUE)
  # Keep letters, numbers, spaces, hyphens, and apostrophes
  txt <- gsub("[^\\p{L}\\p{N}\\s'-]", " ", txt, perl = TRUE)
  # Split by whitespace and count non-empty words
  words <- unlist(strsplit(txt, "\\s+", perl = TRUE))
  words <- words[nzchar(words)]
  length(words)
}
txt <- get_response_text()
n <- count_words(txt)
minw <- as.integer(params$word_min)
maxw <- as.integer(params$word_max)
in_range <- n >= minw && n <= maxw
cat(sprintf("**Word count:** %d  \n", n))
cat(sprintf("**Required range (%s):** %d–%d words  \n",
            toupper(params$course), minw, maxw))
cat(if (in_range) "**Status:** ✅ In range\n" else "**Status:** ❌ Out of range\n")
```
